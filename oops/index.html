<!DOCTYPE html>
<!-- saved from url=(0151)file:///private/var/folders/4k/hypx4nqj22l284yvfjsmbm2m0000gn/T/remote-file-preview-0C530356-53D3-417D-AA56-5D5A2E839AC1/oops_interactive_redesign.html -->
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>OOPS: Interview Cheatsheet</title>
  <style>
    :root {
      --bg-color: #111827;
      --surface-color: #1E293B;
      --border-color: #334155;
      --accent: #38BDF8;
      --text-color: #d1d5db;
      --heading-color: #e2e8f0;
      --code-bg: #0f172a;
      --code-border: #1e293b;
      --string-color: #a7f3d0;
      --comment-color: #6b7280;
      --keyword-color: #38BDF8;
      --type-color: #F9A8D4;
    }

    * {
      box-sizing: border-box;
    }

    html {
      scroll-behavior: smooth;
    }

    body {
      margin: 0;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
      background: var(--bg-color);
      color: var(--text-color);
      line-height: 1.6;
    }

    header {
      background: var(--surface-color);
      color: var(--heading-color);
      padding: 1rem;
      position: sticky;
      top: 0;
      z-index: 1000;
      border-bottom: 1px solid var(--border-color);
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    header h1 {
      margin: 0;
      font-size: 1.5rem;
      font-weight: 600;
    }

    /* Layout */
    .layout {
      display: flex;
      min-height: 100vh;
    }

    nav {
      width: 250px;
      background: var(--surface-color);
      border-right: 1px solid var(--border-color);
      padding: 1rem;
      position: sticky;
      top: 4rem;
      height: calc(100vh - 4rem);
      overflow-y: auto;
      transition: transform 0.3s ease;
    }

    nav ul {
      list-style: none;
      padding: 0;
      margin: 0;
    }

    nav li + li {
      margin-top: 0.25rem;
    }

    nav a {
      display: block;
      padding: 0.5rem 0.75rem;
      color: var(--text-color);
      text-decoration: none;
      border-radius: 4px;
      transition: background-color 0.3s;
    }

    nav a:hover {
      background: var(--border-color);
    }

    nav a.active {
      background: var(--accent);
      color: #0f172a;
      font-weight: 500;
    }

    /* Mobile nav */
    #nav-toggle {
      display: none;
      background: none;
      border: none;
      color: var(--text-color);
      font-size: 1.5rem;
      cursor: pointer;
    }

    /* Main content */
    main {
      flex: 1;
      padding: 2rem;
      max-width: 1000px;
      margin: 0 auto;
    }

    h2 {
      color: var(--heading-color);
      margin-top: 2rem;
      margin-bottom: 0.5rem;
      font-size: 1.3rem;
    }

    h3 {
      color: var(--heading-color);
      margin-top: 1.5rem;
      margin-bottom: 0.5rem;
      font-size: 1.1rem;
    }

    p, li {
      color: var(--text-color);
      font-size: 0.95rem;
    }

    /* Details styling */
    details {
      background: var(--surface-color);
      border: 1px solid var(--border-color);
      border-radius: 6px;
      margin-bottom: 1rem;
      overflow: hidden;
    }

    summary {
      display: flex;
      align-items: center;
      cursor: pointer;
      padding: 1rem;
      font-weight: 600;
      color: var(--heading-color);
      user-select: none;
    }

    summary::marker {
      content: '';
    }

    summary::before {
      content: '\25B6';
      /* Right pointing triangle */
      color: var(--accent);
      margin-right: 0.5rem;
      transition: transform 0.3s ease;
    }

    details[open] summary::before {
      transform: rotate(90deg);
    }

    summary:hover {
      background: var(--border-color);
    }

    details > div {
      padding: 1rem;
      border-top: 1px solid var(--border-color);
    }

    /* Code blocks */
    pre {
      background: var(--code-bg);
      border: 1px solid var(--code-border);
      border-radius: 6px;
      padding: 1rem;
      position: relative;
      overflow: auto;
      margin-top: 1rem;
      margin-bottom: 1rem;
    }

    pre code {
      font-family: 'Courier New', monospace;
      font-size: 0.9rem;
      white-space: pre;
      color: var(--text-color);
    }

    .copy-btn {
      position: absolute;
      top: 0.5rem;
      right: 0.5rem;
      background: var(--surface-color);
      border: 1px solid var(--border-color);
      color: var(--text-color);
      padding: 0.25rem 0.5rem;
      font-size: 0.75rem;
      border-radius: 4px;
      cursor: pointer;
      transition: background-color 0.3s;
    }

    .copy-btn:hover {
      background: var(--accent);
      color: #0f172a;
    }

    /* Syntax highlighting */
    /* Syntax highlighting using data-token attributes to avoid collisions
       with the keyword "class" in HTML attributes. */
    [data-token="keyword"] {
      color: var(--keyword-color);
    }
    [data-token="string"] {
      color: var(--string-color);
    }
    [data-token="comment"] {
      color: var(--comment-color);
      font-style: italic;
    }
    [data-token="type"] {
      color: var(--type-color);
    }

    /* Diagrams */
    .diagram {
      text-align: center;
      margin: 1rem 0;
    }

    /* FAQ styling */
    .faq {
      margin-top: 2rem;
      border-top: 1px solid var(--border-color);
      padding-top: 1rem;
    }

    .faq h2 {
      margin-top: 0;
    }

    .faq details {
      background: #0f172a;
    }

    /* Fade-in animations */
    .section {
      opacity: 0;
      transform: translateY(20px);
      transition: opacity 0.6s ease-out, transform 0.6s ease-out;
    }

    .section.visible {
      opacity: 1;
      transform: none;
    }

    /* Responsive design */
    @media (max-width: 768px) {
      nav {
        position: fixed;
        top: 0;
        left: 0;
        height: 100vh;
        transform: translateX(-100%);
        z-index: 1000;
      }
      nav.open {
        transform: translateX(0);
      }
      #nav-toggle {
        display: block;
      }
      .layout {
        flex-direction: column;
      }
      main {
        padding: 1rem;
      }
    }
  </style>
</head>
<body>
  <header>
    <button id="nav-toggle" aria-label="Toggle navigation">☰</button>
    <h1>OOPS: Interview Cheatsheet</h1>
  </header>
  <div class="layout">
    <nav id="sidebar">
      <ul id="nav-list">
        <!-- Navigation links will be populated by JavaScript -->
      <li><a href="file:///private/var/folders/4k/hypx4nqj22l284yvfjsmbm2m0000gn/T/remote-file-preview-0C530356-53D3-417D-AA56-5D5A2E839AC1/oops_interactive_redesign.html#introduction">Introduction</a></li><li><a href="file:///private/var/folders/4k/hypx4nqj22l284yvfjsmbm2m0000gn/T/remote-file-preview-0C530356-53D3-417D-AA56-5D5A2E839AC1/oops_interactive_redesign.html#classes-and-objects">Classes and Objects</a></li><li><a href="file:///private/var/folders/4k/hypx4nqj22l284yvfjsmbm2m0000gn/T/remote-file-preview-0C530356-53D3-417D-AA56-5D5A2E839AC1/oops_interactive_redesign.html#encapsulation">Encapsulation</a></li><li><a href="file:///private/var/folders/4k/hypx4nqj22l284yvfjsmbm2m0000gn/T/remote-file-preview-0C530356-53D3-417D-AA56-5D5A2E839AC1/oops_interactive_redesign.html#abstraction">Abstraction</a></li><li><a href="file:///private/var/folders/4k/hypx4nqj22l284yvfjsmbm2m0000gn/T/remote-file-preview-0C530356-53D3-417D-AA56-5D5A2E839AC1/oops_interactive_redesign.html#inheritance">Inheritance</a></li><li><a href="file:///private/var/folders/4k/hypx4nqj22l284yvfjsmbm2m0000gn/T/remote-file-preview-0C530356-53D3-417D-AA56-5D5A2E839AC1/oops_interactive_redesign.html#polymorphism">Polymorphism</a></li><li><a href="file:///private/var/folders/4k/hypx4nqj22l284yvfjsmbm2m0000gn/T/remote-file-preview-0C530356-53D3-417D-AA56-5D5A2E839AC1/oops_interactive_redesign.html#constructors-destructors">Constructors &amp; Destructors</a></li><li><a href="file:///private/var/folders/4k/hypx4nqj22l284yvfjsmbm2m0000gn/T/remote-file-preview-0C530356-53D3-417D-AA56-5D5A2E839AC1/oops_interactive_redesign.html#access-modifiers">Access Modifiers</a></li><li><a href="file:///private/var/folders/4k/hypx4nqj22l284yvfjsmbm2m0000gn/T/remote-file-preview-0C530356-53D3-417D-AA56-5D5A2E839AC1/oops_interactive_redesign.html#static-members">Static Members &amp; Static Functions</a></li><li><a href="file:///private/var/folders/4k/hypx4nqj22l284yvfjsmbm2m0000gn/T/remote-file-preview-0C530356-53D3-417D-AA56-5D5A2E839AC1/oops_interactive_redesign.html#friend-functions">Friend Functions &amp; Friend Classes</a></li><li><a href="file:///private/var/folders/4k/hypx4nqj22l284yvfjsmbm2m0000gn/T/remote-file-preview-0C530356-53D3-417D-AA56-5D5A2E839AC1/oops_interactive_redesign.html#this-pointer">The this Pointer</a></li><li><a href="file:///private/var/folders/4k/hypx4nqj22l284yvfjsmbm2m0000gn/T/remote-file-preview-0C530356-53D3-417D-AA56-5D5A2E839AC1/oops_interactive_redesign.html#overloading-overriding">Method Overloading &amp; Overriding</a></li><li><a href="file:///private/var/folders/4k/hypx4nqj22l284yvfjsmbm2m0000gn/T/remote-file-preview-0C530356-53D3-417D-AA56-5D5A2E839AC1/oops_interactive_redesign.html#virtual-functions">Virtual Functions &amp; Dynamic Binding</a></li><li><a href="file:///private/var/folders/4k/hypx4nqj22l284yvfjsmbm2m0000gn/T/remote-file-preview-0C530356-53D3-417D-AA56-5D5A2E839AC1/oops_interactive_redesign.html#abstract-classes">Pure Virtual Functions &amp; Abstract Classes</a></li><li><a href="file:///private/var/folders/4k/hypx4nqj22l284yvfjsmbm2m0000gn/T/remote-file-preview-0C530356-53D3-417D-AA56-5D5A2E839AC1/oops_interactive_redesign.html#templates">Templates &amp; Generic Programming</a></li><li><a href="file:///private/var/folders/4k/hypx4nqj22l284yvfjsmbm2m0000gn/T/remote-file-preview-0C530356-53D3-417D-AA56-5D5A2E839AC1/oops_interactive_redesign.html#differences-c-cpp">Differences between C and C++</a></li><li><a href="file:///private/var/folders/4k/hypx4nqj22l284yvfjsmbm2m0000gn/T/remote-file-preview-0C530356-53D3-417D-AA56-5D5A2E839AC1/oops_interactive_redesign.html#struct-vs-class">Difference between struct and class</a></li><li><a href="file:///private/var/folders/4k/hypx4nqj22l284yvfjsmbm2m0000gn/T/remote-file-preview-0C530356-53D3-417D-AA56-5D5A2E839AC1/oops_interactive_redesign.html#memory-allocation">Static vs Dynamic Memory Allocation</a></li><li><a href="file:///private/var/folders/4k/hypx4nqj22l284yvfjsmbm2m0000gn/T/remote-file-preview-0C530356-53D3-417D-AA56-5D5A2E839AC1/oops_interactive_redesign.html#nested-classes">Nested Classes</a></li><li><a href="file:///private/var/folders/4k/hypx4nqj22l284yvfjsmbm2m0000gn/T/remote-file-preview-0C530356-53D3-417D-AA56-5D5A2E839AC1/oops_interactive_redesign.html#exception-handling">Exception Handling</a></li><li><a href="file:///private/var/folders/4k/hypx4nqj22l284yvfjsmbm2m0000gn/T/remote-file-preview-0C530356-53D3-417D-AA56-5D5A2E839AC1/oops_interactive_redesign.html#what-is-the-difference-between-overloading-and-overriding-">What is the difference between overloading and overriding?</a></li><li><a href="file:///private/var/folders/4k/hypx4nqj22l284yvfjsmbm2m0000gn/T/remote-file-preview-0C530356-53D3-417D-AA56-5D5A2E839AC1/oops_interactive_redesign.html#why-should-a-base-class-destructor-be-virtual-">Why should a base class destructor be virtual?</a></li><li><a href="file:///private/var/folders/4k/hypx4nqj22l284yvfjsmbm2m0000gn/T/remote-file-preview-0C530356-53D3-417D-AA56-5D5A2E839AC1/oops_interactive_redesign.html#can-a-copy-constructor-be-private-">Can a copy constructor be private?</a></li><li><a href="file:///private/var/folders/4k/hypx4nqj22l284yvfjsmbm2m0000gn/T/remote-file-preview-0C530356-53D3-417D-AA56-5D5A2E839AC1/oops_interactive_redesign.html#what-is-the-rule-of-three-five-">What is the rule of three/five?</a></li><li><a href="file:///private/var/folders/4k/hypx4nqj22l284yvfjsmbm2m0000gn/T/remote-file-preview-0C530356-53D3-417D-AA56-5D5A2E839AC1/oops_interactive_redesign.html#what-is-a-pure-virtual-function-" class="active">What is a pure virtual function?</a></li></ul>
    </nav>
    <main id="content">
      <section id="introduction" class="section visible">
        <h2>Introduction</h2>
        <p>
          Object‑oriented programming (OOP) is a programming paradigm that organizes
          software design around data, or <em>objects</em>, rather than functions and
          logic. An object encapsulates data and behavior, enabling reuse, modularity
          and flexibility. This cheat‑sheet summarizes the core concepts of OOP,
          focusing on C++ features. Each section below can be expanded or collapsed
          using the headers to help you study interactively.
        </p>
      </section>

      <!-- Classes and Objects -->
      <details id="classes-and-objects" class="section visible">
        <summary>Classes and Objects</summary>
        <div>
          <p>
            A <strong>class</strong> is a user‑defined type that acts as a blueprint
            for creating objects. It groups <em>data members</em> (attributes) and
            <em>member functions</em> (methods) together. No memory is allocated
            when the class is defined; memory is allocated only when you create
            an <strong>object</strong> (an instance of the class).
          </p>
          <p>
            To create an object you instantiate the class. Each object gets its
            own copy of the non‑static data members, while static members are
            shared by all objects of that class.
          </p>
          <pre><code><span data-token="comment">// <span data-token="type">Define</span> a simple <span data-token="keyword">class</span></span>
<span data-token="keyword">class</span> <span data-token="type">Point</span> {
  <span data-token="keyword">private</span>:
    <span data-token="keyword">int</span> x;
    <span data-token="keyword">int</span> y;
  <span data-token="keyword">public</span>:
    <span data-token="keyword">void</span> set(<span data-token="keyword">int</span> xVal, <span data-token="keyword">int</span> yVal) {
      x = xVal;
      y = yVal;
    }
    <span data-token="keyword">void</span> print() <span data-token="keyword">const</span> {
      std::cout &lt;&lt; <span data-token="string">"<span data-token="type">Point</span>("</span> &lt;&lt; x &lt;&lt; <span data-token="string">", "</span> &lt;&lt; y &lt;&lt; <span data-token="string">")\n"</span>;
    }
};

<span data-token="keyword">int</span> main() {
  <span data-token="type">Point</span> p;      <span data-token="comment">// object instantiation allocates memory</span>
  p.set(2, 3);
  p.print();    <span data-token="comment">// prints <span data-token="string">"<span data-token="type">Point</span>(2, 3)"</span></span>
  <span data-token="keyword">return</span> 0;
}
</code><button class="copy-btn">Copy</button></pre>
          <div class="diagram">
            <!-- Encapsulation diagram: class containing data and methods -->
            <svg width="320" height="180" viewBox="0 0 320 180" xmlns="http://www.w3.org/2000/svg">
              <rect x="10" y="10" width="300" height="160" rx="6" ry="6" fill="var(--surface-color)" stroke="var(--accent)" stroke-width="2"></rect>
              <text x="160" y="35" text-anchor="middle" fill="var(--heading-color)" font-weight="bold">Class</text>
              <rect x="30" y="60" width="120" height="60" rx="4" ry="4" fill="var(--code-bg)" stroke="var(--accent)"></rect>
              <text x="90" y="95" text-anchor="middle" fill="var(--heading-color)">Data</text>
              <rect x="170" y="60" width="120" height="60" rx="4" ry="4" fill="var(--code-bg)" stroke="var(--accent)"></rect>
              <text x="230" y="95" text-anchor="middle" fill="var(--heading-color)">Methods</text>
              <text x="160" y="140" text-anchor="middle" fill="var(--text-color)" font-size="0.75rem">Encapsulation binds data and methods together</text>
            </svg>
          </div>
        </div>
      </details>

      <!-- Encapsulation -->
      <details id="encapsulation" class="section visible">
        <summary>Encapsulation</summary>
        <div>
          <p>
            <strong>Encapsulation</strong> is the concept of binding data and the
            operations that manipulate that data into a single unit (class), and
            restricting access to the inner workings of that unit. This helps
            protect an object’s state from unintended interference and misuse by
            other parts of the program. Data members are often marked as
            <code>private</code> or <code>protected</code> to enforce encapsulation,
            while methods provide controlled access via public interfaces.
          </p>
          <p>
            By hiding implementation details, encapsulation reduces complexity and
            increases maintainability. Changes to the internal implementation of a
            class do not affect code that uses the class as long as the public
            interface remains the same.
          </p>
        </div>
      </details>

      <!-- Abstraction -->
      <details id="abstraction" class="section visible">
        <summary>Abstraction</summary>
        <div>
          <p>
            <strong>Abstraction</strong> refers to the act of exposing only the
            essential features of an object while hiding the unnecessary
            background details. In C++, abstraction can be achieved using classes
            (public methods expose the required behavior) and header files (only
            declarations are visible to users while definitions remain hidden in
            implementation files).
          </p>
          <p>
            For example, the standard library header <code>&lt;cmath&gt;</code>
            declares mathematical functions like <code>pow()</code> and
            <code>sqrt()</code>. You can call these functions without knowing how
            they are implemented.
          </p>
        </div>
      </details>

      <!-- Inheritance -->
      <details id="inheritance" class="section visible">
        <summary>Inheritance</summary>
        <div>
          <p>
            <strong>Inheritance</strong> allows a new class (derived class) to
            acquire the properties and behavior of an existing class (base class).
            It promotes code reuse and establishes an <em>is‑a</em> relationship. A
            derived class can extend or modify the behavior of the base class.
          </p>
          <p>
            There are several types of inheritance:
          </p>
          <ul>
            <li>Single Inheritance: one base class and one derived class.</li>
            <li>Multilevel Inheritance: a chain of inheritance (A → B → C).</li>
            <li>Multiple Inheritance: a class inherits from more than one base class.</li>
            <li>Hierarchical Inheritance: one base class with multiple derived classes.</li>
            <li>Hybrid Inheritance: a combination of multiple and multilevel inheritance.</li>
          </ul>
          <div class="diagram">
            <!-- Inheritance diagram (redesigned) -->
            <svg width="320" height="200" viewBox="0 0 320 200" xmlns="http://www.w3.org/2000/svg">
              <defs>
                <marker id="arrowhead" markerWidth="10" markerHeight="10" refX="5" refY="5" orient="auto">
                  <polygon points="0 0, 10 5, 0 10" fill="var(--accent)"></polygon>
                </marker>
              </defs>
              <!-- Base class -->
              <rect x="130" y="20" width="60" height="40" rx="4" ry="4" fill="var(--surface-color)" stroke="var(--accent)"></rect>
              <text x="160" y="45" text-anchor="middle" fill="var(--heading-color)" font-size="0.85rem">Base</text>
              <!-- Derived classes -->
              <rect x="40" y="120" width="60" height="40" rx="4" ry="4" fill="var(--surface-color)" stroke="var(--border-color)"></rect>
              <text x="70" y="145" text-anchor="middle" fill="var(--text-color)" font-size="0.8rem">Derived1</text>
              <rect x="130" y="120" width="60" height="40" rx="4" ry="4" fill="var(--surface-color)" stroke="var(--border-color)"></rect>
              <text x="160" y="145" text-anchor="middle" fill="var(--text-color)" font-size="0.8rem">Derived2</text>
              <rect x="220" y="120" width="60" height="40" rx="4" ry="4" fill="var(--surface-color)" stroke="var(--border-color)"></rect>
              <text x="250" y="145" text-anchor="middle" fill="var(--text-color)" font-size="0.8rem">Derived3</text>
              <!-- Arrows -->
              <line x1="160" y1="60" x2="70" y2="120" stroke="var(--accent)" stroke-width="2" marker-end="url(#arrowhead)"></line>
              <line x1="160" y1="60" x2="160" y2="120" stroke="var(--accent)" stroke-width="2" marker-end="url(#arrowhead)"></line>
              <line x1="160" y1="60" x2="250" y2="120" stroke="var(--accent)" stroke-width="2" marker-end="url(#arrowhead)"></line>
            </svg>
          </div>
          <p>
            The visibility mode (<code>public</code>, <code>protected</code> or
            <code>private</code>) determines how members of the base class are
            treated in the derived class. In public inheritance (the most common
            for <em>is‑a</em> relationships), public members of the base class
            become public in the derived class, and protected members remain
            protected. Private inheritance results in both public and protected
            members of the base becoming private in the derived class.
          </p>
        </div>
      </details>

      <!-- Polymorphism -->
      <details id="polymorphism" class="section visible">
        <summary>Polymorphism</summary>
        <div>
          <p>
            <strong>Polymorphism</strong> means “many forms.” In OOP it refers
            to the ability of a single interface to be used for different data
            types or the ability of functions/methods to behave differently based
            on the object they operate on. Polymorphism is categorized into
            compile‑time (static) and run‑time (dynamic) polymorphism.
          </p>
          <h3>Compile‑time Polymorphism</h3>
          <p>
            Compile‑time polymorphism is achieved through <strong>function
            overloading</strong> and <strong>operator overloading</strong>. The
            compiler resolves which function or operator to call based on the
            number and types of arguments.
          </p>
          <pre><code><span data-token="comment">// <span data-token="type">Function</span> overloading example</span>
#include &lt;iostream&gt;

<span data-token="keyword">void</span> print(<span data-token="keyword">int</span> x) {
  std::cout &lt;&lt; <span data-token="string">"<span data-token="type">Here</span> is <span data-token="keyword">int</span>: "</span> &lt;&lt; x &lt;&lt; <span data-token="string">"\n"</span>;
}

<span data-token="keyword">void</span> print(<span data-token="keyword">double</span> x) {
  std::cout &lt;&lt; <span data-token="string">"<span data-token="type">Here</span> is <span data-token="keyword">double</span>: "</span> &lt;&lt; x &lt;&lt; <span data-token="string">"\n"</span>;
}

<span data-token="keyword">int</span> main() {
  print(10);
  print(3.14);
  <span data-token="keyword">return</span> 0;
}
</code><button class="copy-btn">Copy</button></pre>
          <h3>Run‑time Polymorphism</h3>
          <p>
            Run‑time polymorphism in C++ is achieved via <strong>virtual
            functions</strong>. When you call a virtual function through a pointer
            or reference to a base class, the program decides at run time which
            function to invoke based on the actual type of the object.
          </p>
          <pre><code><span data-token="comment">// <span data-token="type">Virtual</span> function example</span>
<span data-token="keyword">class</span> <span data-token="type">Base</span> {
  <span data-token="keyword">public</span>:
    <span data-token="keyword">virtual</span> <span data-token="keyword">void</span> print() {
      std::cout &lt;&lt; <span data-token="string">"<span data-token="type">This</span> is base print\n"</span>;
    }
    <span data-token="keyword">void</span> show() {
      std::cout &lt;&lt; <span data-token="string">"<span data-token="type">Base</span> show()\n"</span>;
    }
};

<span data-token="keyword">class</span> <span data-token="type">Derived</span> : <span data-token="keyword">public</span> <span data-token="type">Base</span> {
  <span data-token="keyword">public</span>:
    <span data-token="keyword">void</span> print() override {      <span data-token="comment">// overrides <span data-token="type">Base</span>::print</span>
      std::cout &lt;&lt; <span data-token="string">"<span data-token="type">Derived</span> print\n"</span>;
    }
    <span data-token="keyword">void</span> show() {                <span data-token="comment">// hides <span data-token="type">Base</span>::show</span>
      std::cout &lt;&lt; <span data-token="string">"<span data-token="type">Derived</span> show()\n"</span>;
    }
};

<span data-token="keyword">int</span> main() {
  <span data-token="type">Base</span>* bptr;
  <span data-token="type">Derived</span> d;
  bptr = &amp;d;
  bptr-&gt;print(); <span data-token="comment">// calls <span data-token="type">Derived</span>::print() at run time</span>
  bptr-&gt;show();  <span data-token="comment">// calls <span data-token="type">Base</span>::show() (not <span data-token="keyword">virtual</span>)</span>
  <span data-token="keyword">return</span> 0;
}
</code><button class="copy-btn">Copy</button></pre>
          <div class="diagram">
            <!-- Polymorphism diagram -->
            <svg width="320" height="220" viewBox="0 0 320 220" xmlns="http://www.w3.org/2000/svg">
              <rect x="10" y="10" width="300" height="200" rx="6" ry="6" fill="var(--surface-color)" stroke="var(--border-color)"></rect>
              <text x="160" y="30" text-anchor="middle" fill="var(--heading-color)" font-weight="bold">Polymorphism</text>
              <rect x="30" y="60" width="120" height="50" rx="4" ry="4" fill="var(--code-bg)" stroke="var(--accent)"></rect>
              <text x="90" y="90" text-anchor="middle" fill="var(--text-color)" font-size="0.7rem">Function &amp; Operator\nOverloading</text>
              <rect x="170" y="60" width="120" height="50" rx="4" ry="4" fill="var(--code-bg)" stroke="var(--accent)"></rect>
              <text x="230" y="90" text-anchor="middle" fill="var(--text-color)" font-size="0.7rem">Compile‑time</text>
              <rect x="100" y="140" width="120" height="50" rx="4" ry="4" fill="var(--code-bg)" stroke="var(--accent)"></rect>
              <text x="160" y="170" text-anchor="middle" fill="var(--text-color)" font-size="0.7rem">Run‑time\nVirtual Functions</text>
            </svg>
          </div>
        </div>
      </details>

      <!-- Constructors & Destructors -->
      <details id="constructors-destructors" class="section visible">
        <summary>Constructors &amp; Destructors</summary>
        <div>
          <p>
            A <strong>constructor</strong> is a special member function whose job is
            to initialize objects of a class. It has the same name as the class,
            no return type, and is called automatically when an object is created.
            Constructors can be overloaded to provide different ways of
            initializing objects.
          </p>
          <p>
            Common types of constructors:
          </p>
          <ul>
            <li><strong>Default constructor:</strong> takes no arguments and
            initializes members to default values. If you do not provide any
            constructor, C++ generates one implicitly.</li>
            <li><strong>Parameterized constructor:</strong> takes parameters to
            allow customized initialization.</li>
            <li><strong>Copy constructor:</strong> initializes an object by
            copying an existing object of the same class. The compiler provides a
            default copy constructor that performs <em>shallow copy</em>; you can
            write your own to implement <em>deep copy</em> when necessary.</li>
            <li><strong>Dynamic constructor:</strong> uses
            <code>new</code> to allocate memory dynamically inside the
            constructor (useful for classes managing resources).</li>
          </ul>
          <p>
            A <strong>destructor</strong> has the same name as the class preceded
            by a tilde (<code>~</code>) and is automatically invoked when an object
            goes out of scope or is deleted. Destructors free resources acquired
            by the object (e.g., deallocate memory). Only one destructor is
            allowed per class and it cannot take arguments or return a value.
          </p>
          <div class="diagram">
            <!-- Deep vs shallow copy diagram redesigned -->
            <svg width="340" height="200" viewBox="0 0 340 200" xmlns="http://www.w3.org/2000/svg">
              <defs>
                <marker id="arr" markerWidth="10" markerHeight="10" refX="5" refY="5" orient="auto">
                  <polygon points="0 0, 10 5, 0 10" fill="var(--accent)"></polygon>
                </marker>
              </defs>
              <!-- Shallow copy -->
              <rect x="10" y="20" width="60" height="30" rx="4" ry="4" fill="var(--surface-color)" stroke="var(--accent)"></rect>
              <text x="40" y="38" text-anchor="middle" fill="var(--heading-color)" font-size="0.6rem">obj1</text>
              <rect x="100" y="20" width="60" height="30" rx="4" ry="4" fill="var(--surface-color)" stroke="var(--border-color)"></rect>
              <text x="130" y="38" text-anchor="middle" fill="var(--text-color)" font-size="0.6rem">data</text>
              <line x1="70" y1="35" x2="100" y2="35" stroke="var(--accent)" stroke-width="2" marker-end="url(#arr)"></line>
              <rect x="10" y="70" width="60" height="30" rx="4" ry="4" fill="var(--surface-color)" stroke="var(--accent)"></rect>
              <text x="40" y="88" text-anchor="middle" fill="var(--heading-color)" font-size="0.6rem">obj2</text>
              <line x1="70" y1="85" x2="100" y2="35" stroke="var(--accent)" stroke-width="2" marker-end="url(#arr)"></line>
              <text x="180" y="60" fill="var(--text-color)" font-size="0.6rem">Shallow copy: both objects point to same data</text>
              <!-- Deep copy -->
              <rect x="10" y="140" width="60" height="30" rx="4" ry="4" fill="var(--surface-color)" stroke="var(--accent)"></rect>
              <text x="40" y="158" text-anchor="middle" fill="var(--heading-color)" font-size="0.6rem">obj1</text>
              <rect x="100" y="140" width="60" height="30" rx="4" ry="4" fill="var(--surface-color)" stroke="var(--border-color)"></rect>
              <text x="130" y="158" text-anchor="middle" fill="var(--text-color)" font-size="0.6rem">data</text>
              <line x1="70" y1="155" x2="100" y2="155" stroke="var(--accent)" stroke-width="2" marker-end="url(#arr)"></line>
              <rect x="220" y="140" width="60" height="30" rx="4" ry="4" fill="var(--surface-color)" stroke="var(--accent)"></rect>
              <text x="250" y="158" text-anchor="middle" fill="var(--heading-color)" font-size="0.6rem">obj2</text>
              <rect x="310" y="140" width="0" height="0" fill="none"></rect>
              <rect x="280" y="140" width="60" height="30" rx="4" ry="4" fill="var(--surface-color)" stroke="var(--border-color)"></rect>
              <text x="310" y="158" text-anchor="middle" fill="var(--text-color)" font-size="0.6rem">data</text>
              <line x1="250" y1="155" x2="280" y2="155" stroke="var(--accent)" stroke-width="2" marker-end="url(#arr)"></line>
              <text x="180" y="185" fill="var(--text-color)" font-size="0.6rem">Deep copy: each object has its own data</text>
            </svg>
          </div>
        </div>
      </details>

      <!-- Access Modifiers -->
      <details id="access-modifiers" class="section visible">
        <summary>Access Modifiers</summary>
        <div>
          <p>
            C++ uses access specifiers to control visibility of class members:
          </p>
          <table>
            <thead>
              <tr><th>Modifier</th><th>Meaning</th></tr>
            </thead>
            <tbody>
              <tr><td><code>public</code></td><td>Accessible anywhere the object is visible.</td></tr>
              <tr><td><code>protected</code></td><td>Accessible within the class and its derived classes.</td></tr>
              <tr><td><code>private</code></td><td>Accessible only within the class itself.</td></tr>
            </tbody>
          </table>
          <p>
            If no access modifier is specified for a class member, the default is
            <code>private</code> for classes and <code>public</code> for structs.
          </p>
        </div>
      </details>

      <!-- Static Members & Static Functions -->
      <details id="static-members" class="section visible">
        <summary>Static Members &amp; Static Functions</summary>
        <div>
          <p>
            A <strong>static data member</strong> belongs to the class rather than
            to any individual object. Only one copy exists regardless of how many
            objects are created. Static members must be defined outside the class
            definition.
          </p>
          <p>
            A <strong>static member function</strong> can access only static
            members of its class. It does not receive the implicit <code>this</code>
            pointer and can be called using the class name without creating an
            object.
          </p>
          <pre><code><span data-token="comment">// <span data-token="type">Static</span> members example</span>
<span data-token="keyword">class</span> <span data-token="type">Account</span> {
  <span data-token="keyword">private</span>:
    <span data-token="keyword">static</span> <span data-token="keyword">int</span> count;  <span data-token="comment">// declaration</span>
    <span data-token="keyword">double</span> balance;
  <span data-token="keyword">public</span>:
    <span data-token="type">Account</span>() { count++; }
    <span data-token="keyword">static</span> <span data-token="keyword">int</span> getCount() { <span data-token="keyword">return</span> count; }
};

<span data-token="comment">// definition of <span data-token="keyword">static</span> member</span>
<span data-token="keyword">int</span> <span data-token="type">Account</span>::count = 0;

<span data-token="keyword">int</span> main() {
  <span data-token="type">Account</span> a1;
  <span data-token="type">Account</span> a2;
  std::cout &lt;&lt; <span data-token="string">"<span data-token="type">Number</span> of accounts: "</span> &lt;&lt; <span data-token="type">Account</span>::getCount();
  <span data-token="keyword">return</span> 0;
}
</code><button class="copy-btn">Copy</button></pre>
          <p>
            Objects themselves can be declared static. A static object’s lifetime
            extends through the entire program, and its destructor runs when the
            program ends.
          </p>
        </div>
      </details>

      <!-- Friend Functions & Friend Classes -->
      <details id="friend-functions" class="section visible">
        <summary>Friend Functions &amp; Friend Classes</summary>
        <div>
          <p>
            A <strong>friend function</strong> or <strong>friend class</strong> has
            access to the private and protected members of another class. They are
            declared inside the class whose private data should be accessible. Use
            friend features sparingly, as they break encapsulation.
          </p>
          <pre><code><span data-token="comment">// <span data-token="type">Friend</span> <span data-token="keyword">class</span> and <span data-token="keyword">friend</span> function example</span>
<span data-token="keyword">class</span> <span data-token="type">Box</span> {
  <span data-token="keyword">private</span>:
    <span data-token="keyword">double</span> width;
  <span data-token="keyword">public</span>:
    <span data-token="keyword">friend</span> <span data-token="keyword">void</span> setWidth(<span data-token="type">Box</span>&amp; b, <span data-token="keyword">double</span> w); <span data-token="comment">// <span data-token="keyword">friend</span> function declaration</span>
    <span data-token="keyword">void</span> printWidth() <span data-token="keyword">const</span> {
      std::cout &lt;&lt; width &lt;&lt; <span data-token="string">"\n"</span>;
    }
};

<span data-token="keyword">void</span> setWidth(<span data-token="type">Box</span>&amp; b, <span data-token="keyword">double</span> w) { <span data-token="comment">// <span data-token="keyword">friend</span> function definition</span>
  b.width = w;  <span data-token="comment">// can access <span data-token="keyword">private</span> member</span>
}

<span data-token="keyword">int</span> main() {
  <span data-token="type">Box</span> b;
  setWidth(b, 10.0);
  b.printWidth(); <span data-token="comment">// prints 10</span>
  <span data-token="keyword">return</span> 0;
}
</code><button class="copy-btn">Copy</button></pre>
          <p>
            You can also declare an entire class as a friend. Then all member
            functions of the friend class can access private/protected members of
            the class in which friendship is granted.
          </p>
        </div>
      </details>

      <!-- This Pointer -->
      <details id="this-pointer" class="section">
        <summary>The <code>this</code> Pointer</summary>
        <div>
          <p>
            Inside a non‑static member function, the implicit pointer
            <code>this</code> points to the object on which the function was
            called. It is used to access member variables when local variables
            shadow member names and to return the object itself by reference.
          </p>
          <pre><code><span data-token="comment">// <span data-token="type">Using</span> the <span data-token="keyword">this</span> pointer</span>
<span data-token="keyword">class</span> <span data-token="type">Box</span> {
  <span data-token="keyword">private</span>:
    <span data-token="keyword">int</span> l, b, h;
  <span data-token="keyword">public</span>:
    <span data-token="keyword">void</span> set(<span data-token="keyword">int</span> length, <span data-token="keyword">int</span> breadth, <span data-token="keyword">int</span> height) {
      <span data-token="keyword">this</span>-&gt;l = length;   <span data-token="comment">// clarify that l refers to the member</span>
      b = breadth;        <span data-token="comment">// same as <span data-token="keyword">this</span>-&gt;b</span>
      h = height;
    }
};
</code><button class="copy-btn">Copy</button></pre>
          <p>
            Friend functions and static member functions do not receive the
            <code>this</code> pointer because they are not associated with any
            particular object instance.
          </p>
        </div>
      </details>

      <!-- Method Overloading & Overriding -->
      <details id="overloading-overriding" class="section">
        <summary>Method Overloading &amp; Overriding</summary>
        <div>
          <p>
            <strong>Overloading</strong> occurs when multiple functions in the
            same scope have the same name but different parameter lists. The
            compiler chooses the appropriate function based on the arguments at
            compile time.
          </p>
          <p>
            <strong>Overriding</strong> happens when a derived class provides its
            own implementation of a virtual function defined in a base class. It
            enables run‑time polymorphism. The function signature (name, return
            type, and parameters) must be identical. The <code>override</code>
            keyword (C++11 and later) helps detect mistakes.
          </p>
        </div>
      </details>

      <!-- Virtual Functions & Dynamic Binding -->
      <details id="virtual-functions" class="section">
        <summary>Virtual Functions &amp; Dynamic Binding</summary>
        <div>
          <p>
            A <strong>virtual function</strong> is a member function declared with
            the <code>virtual</code> keyword in the base class and redefined in a
            derived class. When you call a virtual function through a base class
            pointer or reference, the call is resolved at run time based on the
            actual object type (late binding). This enables run‑time polymorphism.
          </p>
          <p>
            Virtual functions cannot be static or friends of another class.
          </p>
          <p>
            Internally, C++ compilers typically implement virtual functions using
            a <em>virtual table</em> (vtable) and a hidden pointer (vptr) inside
            each object of classes with virtual functions. The vtable stores
            addresses of virtual functions appropriate for that class. Each class
            has its own vtable, and each object has a vptr pointing to it.
          </p>
          <p>
            To prevent resource leaks when deleting objects via a base class
            pointer, the base class destructor should be declared <code>virtual</code>.
            Otherwise only the base destructor runs, leaving derived class
            resources unreleased (undefined behavior).
          </p>
        </div>
      </details>

      <!-- Pure Virtual Functions & Abstract Classes -->
      <details id="abstract-classes" class="section">
        <summary>Pure Virtual Functions &amp; Abstract Classes</summary>
        <div>
          <p>
            A <strong>pure virtual function</strong> is a virtual function with no
            implementation in the base class. It is declared by assigning
            <code>= 0</code> in its declaration. A class containing at least one
            pure virtual function becomes an <strong>abstract class</strong> and
            cannot be instantiated directly. Abstract classes provide an interface
            for derived classes to implement.
          </p>
          <pre><code><span data-token="comment">// <span data-token="type">Pure</span> <span data-token="keyword">virtual</span> function example</span>
<span data-token="keyword">class</span> <span data-token="type">Shape</span> {
  <span data-token="keyword">public</span>:
    <span data-token="keyword">virtual</span> <span data-token="keyword">void</span> draw() = 0;  <span data-token="comment">// pure <span data-token="keyword">virtual</span> function</span>
    <span data-token="keyword">virtual</span> ~<span data-token="type">Shape</span>() {}       <span data-token="comment">// <span data-token="keyword">virtual</span> destructor</span>
};

<span data-token="keyword">class</span> <span data-token="type">Circle</span> : <span data-token="keyword">public</span> <span data-token="type">Shape</span> {
  <span data-token="keyword">public</span>:
    <span data-token="keyword">void</span> draw() override {
      std::cout &lt;&lt; <span data-token="string">"<span data-token="type">Drawing</span> circle\n"</span>;
    }
};

<span data-token="keyword">int</span> main() {
  <span data-token="comment">// <span data-token="type">Shape</span> s;         // error: cannot instantiate abstract <span data-token="keyword">class</span></span>
  <span data-token="type">Shape</span>* s = <span data-token="keyword">new</span> <span data-token="type">Circle</span>();
  s-&gt;draw();          <span data-token="comment">// calls <span data-token="type">Circle</span>::draw</span>
  <span data-token="keyword">delete</span> s;
  <span data-token="keyword">return</span> 0;
}
</code><button class="copy-btn">Copy</button></pre>
          <p>
            You can still have constructors in an abstract class; derived classes
            must call them explicitly or implicitly. If a derived class fails to
            override a pure virtual function, it remains abstract.
          </p>
        </div>
      </details>

      <!-- Templates & Generic Programming -->
      <details id="templates" class="section">
        <summary>Templates &amp; Generic Programming</summary>
        <div>
          <p>
            <strong>Templates</strong> allow you to write generic functions and
            classes that operate on different data types without rewriting code for
            each type. The compiler generates appropriate instances when the
            template is used.
          </p>
          <pre><code><span data-token="comment">// <span data-token="type">Function</span> <span data-token="keyword">template</span> to <span data-token="keyword">return</span> the maximum of two values</span>
<span data-token="keyword">template</span> &lt;<span data-token="keyword">typename</span> <span data-token="type">T</span>&gt;
<span data-token="type">T</span> myMax(<span data-token="type">T</span> a, <span data-token="type">T</span> b) {
  <span data-token="keyword">return</span> (a &gt; b) ? a : b;
}

<span data-token="keyword">int</span> main() {
  std::cout &lt;&lt; myMax&lt;<span data-token="keyword">int</span>&gt;(3, 7) &lt;&lt; <span data-token="string">"\n"</span>;       <span data-token="comment">// outputs 7</span>
  std::cout &lt;&lt; myMax&lt;<span data-token="keyword">double</span>&gt;(3.5, 2.1) &lt;&lt; <span data-token="string">"\n"</span>; <span data-token="comment">// outputs 3.5</span>
  <span data-token="keyword">return</span> 0;
}
</code><button class="copy-btn">Copy</button></pre>
          <p>
            Class templates work similarly, allowing you to define classes that
            work with different data types. For example, the standard container
            classes such as <code>std::vector&lt;T&gt;</code> are class templates.
          </p>
        </div>
      </details>

      <!-- Differences between C and C++ -->
      <details id="differences-c-cpp" class="section">
        <summary>Differences between C and C++</summary>
        <div>
          <p>
            Although C++ evolved from C and retains many of its features, it adds
            powerful capabilities such as classes, inheritance, polymorphism, and
            templates. Key differences include:
          </p>
          <table>
            <thead>
              <tr><th>Aspect</th><th>C</th><th>C++</th></tr>
            </thead>
            <tbody>
              <tr><td>Programming paradigm</td><td>Procedural</td><td>Hybrid: procedural &amp; object‑oriented</td></tr>
              <tr><td>OOP support</td><td>No native OOP features</td><td>Supports classes, inheritance, polymorphism, encapsulation</td></tr>
              <tr><td>Templates &amp; Generics</td><td>Not available</td><td>Available via templates</td></tr>
              <tr><td>Exception handling</td><td>Not built into language</td><td>Supported with <code>try</code>, <code>catch</code>, <code>throw</code></td></tr>
              <tr><td>Function/operator overloading</td><td>Not supported</td><td>Supported</td></tr>
              <tr><td>Default access</td><td>Functions and variables are global by default</td><td>Class members default to private</td></tr>
              <tr><td>Keywords</td><td>32 keywords</td><td>52 keywords (includes <code>class</code>, <code>public</code>, <code>private</code>, <code>new</code>, <code>delete</code>, <code>try</code>, <code>catch</code>, <code>throw</code>, etc.)</td></tr>
            </tbody>
          </table>
          <p>
            C remains a powerful systems programming language, while C++ is a
            superset that adds object‑oriented and generic programming features.
          </p>
        </div>
      </details>

      <!-- Difference between struct and class -->
      <details id="struct-vs-class" class="section">
        <summary>Difference between <code>struct</code> and <code>class</code></summary>
        <div>
          <p>
            In C++, the only real difference between a <code>struct</code> and a
            <code>class</code> is the default access control. Members of a
            <code>struct</code> default to public, whereas members of a
            <code>class</code> default to private. Both can have member functions,
            constructors, destructors, and can participate in inheritance.
          </p>
          <table>
            <thead>
              <tr><th>Feature</th><th>Struct</th><th>Class</th></tr>
            </thead>
            <tbody>
              <tr><td>Default access</td><td>public</td><td>private</td></tr>
              <tr><td>Encapsulation</td><td>Possible but not enforced by default</td><td>Encouraged (data hiding)</td></tr>
              <tr><td>Use case</td><td>Simple data structures, POD types</td><td>Complex types with behavior</td></tr>
            </tbody>
          </table>
        </div>
      </details>

      <!-- Static vs Dynamic Memory Allocation -->
      <details id="memory-allocation" class="section">
        <summary>Static vs Dynamic Memory Allocation</summary>
        <div>
          <p>
            C++ provides both static and dynamic memory allocation. <strong>Static
            allocation</strong> happens at compile time for local variables and
            static class members. Memory is automatically managed and released
            when the scope ends. <strong>Dynamic allocation</strong> uses
            <code>new</code> to request memory on the heap and <code>delete</code>
            to release it. Classes managing dynamic resources should implement
            proper constructors, copy constructors, assignment operators and
            destructors (often referred to as the Rule of Three/Five).
          </p>
        </div>
      </details>

      <!-- Nested Classes -->
      <details id="nested-classes" class="section">
        <summary>Nested Classes</summary>
        <div>
          <p>
            A <strong>nested class</strong> is a class defined inside another
            class. It has the same access rights as other members of the
            enclosing class. However, members of the enclosing class do not gain
            special access to the nested class; access control still applies.
          </p>
          <pre><code><span data-token="comment">// <span data-token="type">Nested</span> <span data-token="keyword">class</span> example</span>
<span data-token="keyword">class</span> <span data-token="type">Enclosing</span> {
  <span data-token="keyword">private</span>:
    <span data-token="keyword">int</span> x;
  <span data-token="keyword">public</span>:
    <span data-token="keyword">class</span> <span data-token="type">Nested</span> {
      <span data-token="keyword">public</span>:
        <span data-token="keyword">int</span> y;
        <span data-token="keyword">void</span> setY(<span data-token="keyword">int</span> val) { y = val; }
    };
    <span data-token="keyword">void</span> setX(<span data-token="keyword">int</span> val) { x = val; }
    <span data-token="keyword">int</span> getX() <span data-token="keyword">const</span> { <span data-token="keyword">return</span> x; }
};

<span data-token="keyword">int</span> main() {
  <span data-token="type">Enclosing</span>::<span data-token="type">Nested</span> n;
  n.setY(5);
  <span data-token="type">Enclosing</span> e;
  e.setX(10);
  <span data-token="comment">// n.y is <span data-token="keyword">public</span> and accessible</span>
  std::cout &lt;&lt; n.y &lt;&lt; <span data-token="string">", "</span> &lt;&lt; e.getX();
  <span data-token="keyword">return</span> 0;
}
</code><button class="copy-btn">Copy</button></pre>
        </div>
      </details>

      <!-- Exception Handling -->
      <details id="exception-handling" class="section">
        <summary>Exception Handling</summary>
        <div>
          <p>
            C++ provides structured exception handling through
            <code>try</code>, <code>throw</code> and <code>catch</code>. Code that
            may produce an error is placed in a <code>try</code> block. When an
            exception occurs, it is thrown using the <code>throw</code> keyword
            and caught by the matching <code>catch</code> block. A catch block
            with an ellipsis (<code>...</code>) catches any exception type.
          </p>
          <pre><code><span data-token="comment">// <span data-token="type">Exception</span> handling example</span>
<span data-token="keyword">try</span> {
  <span data-token="keyword">int</span> x = -1;
  <span data-token="keyword">if</span> (x &lt; 0) {
    <span data-token="keyword">throw</span> std::runtime_error(<span data-token="string">"<span data-token="type">Negative</span> value not allowed"</span>);
  }
}
<span data-token="keyword">catch</span> (<span data-token="keyword">const</span> std::runtime_error&amp; ex) {
  std::cerr &lt;&lt; <span data-token="string">"<span data-token="type">Caught</span>: "</span> &lt;&lt; ex.what() &lt;&lt; <span data-token="string">"\n"</span>;
}
<span data-token="keyword">catch</span> (...) {
  std::cerr &lt;&lt; <span data-token="string">"<span data-token="type">Caught</span> unknown exception\n"</span>;
}
</code><button class="copy-btn">Copy</button></pre>
          <p>
            Use exceptions for exceptional situations only. Prefer returning error
            codes for normal control flow.
          </p>
        </div>
      </details>

      <!-- FAQ Section -->
      <div class="faq section" id="faq">
        <h2>Frequently Asked Questions</h2>
        <details id="what-is-the-difference-between-overloading-and-overriding-">
          <summary>What is the difference between overloading and overriding?</summary>
          <div>
            <p><strong>Overloading</strong> means having multiple functions with the same name but different parameter lists in the same scope. The compiler chooses which one to call based on the arguments at compile time. <strong>Overriding</strong> refers to redefining a virtual function in a derived class with the same signature as in the base class. It enables run‑time polymorphism when functions are called through base class pointers or references.</p>
          </div>
        </details>
        <details id="why-should-a-base-class-destructor-be-virtual-">
          <summary>Why should a base class destructor be virtual?</summary>
          <div>
            <p>If you delete a derived class object through a pointer to the base class and the base class destructor is not virtual, only the base destructor runs. The derived class resources will not be released, leading to undefined behaviour. Declaring the destructor as <code>virtual</code> ensures that the derived class destructor is invoked properly.</p>
          </div>
        </details>
        <details id="can-a-copy-constructor-be-private-">
          <summary>Can a copy constructor be private?</summary>
          <div>
            <p>Yes. Declaring the copy constructor as private prevents copying of objects from outside the class. This technique is sometimes used to implement the Singleton pattern or to disable copying.</p>
          </div>
        </details>
        <details id="what-is-the-rule-of-three-five-">
          <summary>What is the rule of three/five?</summary>
          <div>
            <p>The Rule of Three states that if a class defines one of the following: a destructor, a copy constructor, or a copy assignment operator, it should probably explicitly define all three. The Rule of Five extends this concept to move constructor and move assignment operator (C++11). These special member functions are needed for proper management of resources.</p>
          </div>
        </details>
        <details id="what-is-a-pure-virtual-function-">
          <summary>What is a pure virtual function?</summary>
          <div>
            <p>A pure virtual function is a virtual function that is declared with <code>= 0</code> in the base class. It has no implementation in the base class and must be overridden by derived classes. Classes containing pure virtual functions are abstract and cannot be instantiated.</p>
          </div>
        </details>
      </div>

    </main>
  </div>
  <script>
    // Toggle navigation on mobile
    const navToggle = document.getElementById('nav-toggle');
    const sidebar = document.getElementById('sidebar');
    navToggle.addEventListener('click', () => {
      sidebar.classList.toggle('open');
    });

    // Generate navigation links from sections and details
    function slugify(text) {
      return text.toLowerCase().replace(/[^a-z0-9]+/g, '-');
    }
    const navList = document.getElementById('nav-list');
    const sections = [];
    // Add introduction
    const introEl = document.getElementById('introduction');
    sections.push(introEl);
    // Add details summaries
    document.querySelectorAll('details').forEach(det => {
      sections.push(det);
    });
    sections.forEach(el => {
      let id = el.id;
      if (!id) {
        // assign id based on summary or heading
        const summary = el.querySelector('summary');
        if (summary) {
          id = slugify(summary.textContent.trim());
          el.id = id;
        } else {
          const heading = el.querySelector('h2');
          id = slugify(heading.textContent.trim());
          el.id = id;
        }
      }
      const title = el.querySelector('summary') ? el.querySelector('summary').textContent.trim() : el.querySelector('h2').textContent.trim();
      const li = document.createElement('li');
      const a = document.createElement('a');
      a.href = '#' + id;
      a.textContent = title;
      li.appendChild(a);
      navList.appendChild(li);
    });

    // Smooth scrolling active link highlighting
    const navLinks = document.querySelectorAll('nav a');
    function activateNav() {
      let index = sections.length - 1;
      for (let i = 0; i < sections.length; i++) {
        const rect = sections[i].getBoundingClientRect();
        if (rect.top <= 100) {
          index = i;
        }
      }
      navLinks.forEach((link, i) => {
        if (i === index) {
          link.classList.add('active');
        } else {
          link.classList.remove('active');
        }
      });
    }
    window.addEventListener('scroll', activateNav);
    activateNav();

    // Fade-in animation using IntersectionObserver
    const observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          entry.target.classList.add('visible');
          observer.unobserve(entry.target);
        }
      });
    }, { threshold: 0.1 });
    document.querySelectorAll('.section').forEach(section => {
      observer.observe(section);
    });

    // Code copy buttons and syntax highlighting
    /*
    function highlightCode() {
      document.querySelectorAll('pre code').forEach(block => {
        const code = block.textContent;
        let html = code
          .replace(/&/g, '&amp;')
          .replace(/</g, '&lt;')
          .replace(/>/g, '&gt;');
        // Comments
        html = html.replace(/(\/\/.*$)/gm, '<span class="token comment">$1</span>');
        // Strings
        html = html.replace(/("[^"
]*"|'[^'
]*')/g, '<span class="token string">$1</span>');
        // Keywords
        const keywords = /((class|struct|virtual|public|private|protected|int|double|float|void|return|delete|new|template|typename|throw|try|catch|if|else|const|static|friend|this))/g;
        html = html.replace(keywords, '<span class="token keyword">$1</span>');
        // Types
        html = html.replace(/([A-Z][A-Za-z0-9_]*)/g, '<span class="token type">$1</span>');
        block.innerHTML = html;
      });
    }
    // The stray parenthesis and brace below were removed during redesign to prevent syntax errors

    // Old addCopyButtons definition removed. See new implementation above.
    */

    // Override highlightCode and addCopyButtons with improved implementations
    function highlightCode() {
      document.querySelectorAll('pre code').forEach(block => {
        let text = block.textContent;
        // Escape HTML special characters
        text = text.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
        // Use the pilcrow character (§) as a placeholder marker to avoid collisions
        const marker = '\u00B6';
        // Highlight keywords by marking them with placeholder tokens
        const keywordPattern = /\b(class|struct|virtual|public|private|protected|int|double|float|void|return|delete|new|template|typename|throw|try|catch|if|else|const|static|friend|this)\b/g;
        text = text.replace(keywordPattern, `${marker}k${marker}$1${marker}k${marker}`);
        // Highlight type names (beginning with uppercase letter)
        text = text.replace(/\b([A-Z][A-Za-z0-9_]*)\b/g, `${marker}t${marker}$1${marker}t${marker}`);
        // Highlight single-line comments
        text = text.replace(/(\/\/.*$)/gm, `${marker}c${marker}$1${marker}c${marker}`);
        // Highlight simple string literals
        // Highlight string literals (supports escaped characters)
        text = text.replace(/("(?:\\.|[^"\\])*"|'(?:\\.|[^'\\])*')/g, `${marker}s${marker}$1${marker}s${marker}`);
        // Replace placeholders with actual span elements
        const replaceToken = (typeCode, tokenName) => {
          const regex = new RegExp(`${marker}${typeCode}${marker}(.*?)${marker}${typeCode}${marker}`, 'g');
          text = text.replace(regex, `<span data-token="${tokenName}">$1</span>`);
        };
        replaceToken('c', 'comment');
        replaceToken('s', 'string');
        replaceToken('k', 'keyword');
        replaceToken('t', 'type');
        // Assign the highlighted HTML
        block.innerHTML = text;
      });
    }

    function addCopyButtons() {
      document.querySelectorAll('pre').forEach(pre => {
        // remove existing copy buttons to avoid duplicates
        const existing = pre.querySelector('.copy-btn');
        if (existing) existing.remove();
        const button = document.createElement('button');
        button.className = 'copy-btn';
        button.textContent = 'Copy';
        button.addEventListener('click', () => {
          const codeText = pre.querySelector('code').textContent;
          navigator.clipboard.writeText(codeText).then(() => {
            button.textContent = 'Copied!';
            setTimeout(() => button.textContent = 'Copy', 2000);
          });
        });
        pre.appendChild(button);
      });
    }

    document.addEventListener('DOMContentLoaded', () => {
      highlightCode();
      addCopyButtons();
    });
  </script>


</body></html>
